#pragma config(Motor,  motorA,          motorRight,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorLeft,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float robotWidth = 4.0;
const float wheelDiameter = 2.0;
const float encoderConversion = 360.0/wheelDiameter/PI;

void encodersReset()
{
	nMotorEncoder[motorLeft] = 0;
	nMotorEncoder[motorRight] = 0;
}

void motorStop()
{
	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}

void move(float turnRadius, int power, float angle) {
	encodersReset();
	float radiusLeft = turnRadius + 0.5*robotWidth;
	float radiusRight = turnRadius - 0.5*robotWidth;
	float encRDist = radiusRight * angle * encoderConversion;
	float encLDist = radiusLeft * angle * encoderConversion;
	writeDebugStreamLine("radiusLeft: %f, radiusRight: %f, encLDist: %f, encRDist %f", radiusLeft, radiusRight, encLDist, encRDist);
	motor[motorLeft]=power;
	motor[motorRight]=round(power * radiusLeft/radiusRight);
	while((abs(nMotorEncoder[motorRight])< abs(encRDist)))
	{
	}
}

//(abs(nMotorEncoder[motorLeft]) < abs(encLDist))
//(abs(nMotorEncoder[motorRight])< abs(encRDist))

void encoderDisplay()
{
	writeDebugStreamLine("right: %d left: %d",nMotorEncoder[motorRight],nMotorEncoder[motorLeft]);
}

task main()
{
	encodersReset();
	move(-2, 50, PI/2);
	motorStop();
	encoderDisplay();
}